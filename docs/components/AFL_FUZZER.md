# AFL++ Fuzzer Component

## Overview
The **AFL++ Fuzzer** (`src/fuzzing/afl_fuzzer.py`) is the workhorse of the NeuroFuzz system. It wraps the industry-standard `afl-fuzz` binary, managing its lifecycle, configuration, and statistics collection.

Unlike traditional usage where a user manually runs AFL++, this component allows the `Orchestrator` to programmatically start, stop, and monitor the fuzzer as part of the hybrid workflow.

## Key Features

### 1. Process Management
- **Subprocess Control**: Runs `afl-fuzz` as a background subprocess using `subprocess.Popen`.
- **Environment Configuration**: Automatically sets critical environment variables for headless operation:
  - `AFL_NO_UI=1`: Disables the ncurses UI.
  - `AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1`: Suppresses core pattern warnings.
  - `AFL_SKIP_CPUFREQ=1`: Allows running on VMs/containers without scaling governor tweaks.
- **Clean Shutdown**: Implements a graceful shutdown sequence (`SIGTERM`, wait, `SIGKILL`) to ensure no zombie processes remain.

### 2. Resume Capability
The fuzzer supports two modes of operation:
- **Fresh Start**: Cleans the output directory (with optional backup) and starts from the seed directory.
- **Resume Mode**: If `resume=True` and a valid output directory exists, it restarts AFL++ using the existing queue (`-i -`), preserving past progress.

### 3. Real-time Statistics
It parses the `fuzzer_stats` file generated by AFL++ to provide real-time feedback to the RL agent.

**Field Mapping (AFL++ v4.x):**
| NeuroFuzz Metric | AFL++ Field | Description |
| :--- | :--- | :--- |
| `total_executions` | `execs_done` | Total test cases run. |
| `exec_speed` | `execs_per_sec` | Executions per second. |
| `paths_total` | `corpus_count` | Number of interesting test cases in queue. |
| `crashes_total` | `saved_crashes` | Unique crashes found. |
| `coverage_percentage` | `bitmap_cvg` | Bitmap coverage (e.g., "32.00%"). |

### 4. Robust Error Handling
- **Path Resolution**: Converts all paths to absolute paths (a strict requirement for AFL++).
- **Health Monitoring**: `is_running()` checks both the process status and the freshness of the `fuzzer_stats` file (with a 120s tolerance for symbolic execution pauses).
- **Startup Validation**: Verifies that AFL++ started correctly by checking the process exit code and stderr output immediately after launch.

## Technical Implementation

### Initialization
```python
fuzzer = AFLFuzzer(afl_binary="afl-fuzz")
```
It verifies that `afl-fuzz` is installed and available in the system PATH.

### Starting the Fuzzer
```python
success = fuzzer.start(
    binary_path="/abs/path/to/binary",
    input_dir="/abs/path/to/seeds",
    output_dir="/abs/path/to/output",
    timeout_ms=1000
)
```
This constructs the command line:
```bash
afl-fuzz -i <input_dir> -o <output_dir> -m none -t 1000 -- <binary_path>
```
*Note: Currently supports stdin-based fuzzing. Future updates will add `@@` support for file-based inputs.*

### Configuration
Configured via `configs/*.yml` under `afl`:
```yaml
afl:
  input_dir: "data/inputs"
  output_dir: "data/outputs"
  timeout_ms: 1000
  resume: false
  force_clean: true
```

## Integration with Orchestrator
The `Orchestrator` uses the `AFLFuzzer` to:
1.  **Start Fuzzing**: At the beginning of a campaign or after a symbolic execution phase.
2.  **Monitor Progress**: Periodically calls `get_stats()` to feed the RL agent's observation space.
3.  **Stop Fuzzing**: Pauses the fuzzer when the RL agent decides to switch to symbolic execution (to free up CPU resources).
